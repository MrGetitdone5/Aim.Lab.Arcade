<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Blaster Range</title>
  <style>
    html,body{margin:0;height:100%;background:#0b0f14;color:#e8eef7;font-family:system-ui}
    canvas{display:block;margin:0 auto;background:#111827;touch-action:none}
    .hud{position:fixed;left:12px;top:10px;font-size:14px;line-height:1.4}
  </style>
</head>
<body>
  <div class="hud" id="hud"></div>
  <canvas id="c" width="420" height="800"></canvas>

<script>
const c = document.getElementById('c'), ctx = c.getContext('2d');
const hud = document.getElementById('hud');

let cross = {x: c.width/2, y: c.height*0.7};
let score = 0, shots = 0, hits = 0;

let gun = {
  magSize: 12,
  ammo: 12,
  cooldownMs: 120,
  lastShot: 0,
  reloadMs: 900,
  reloading: false,
};

let spread = 0; // pixels added to aim
const targets = [];
function spawnTarget(){
  const r = 22 + Math.random()*18;
  targets.push({
    x: 60 + Math.random()*(c.width-120),
    y: 120 + Math.random()*240,
    r,
    alive: true
  });
}
for(let i=0;i<6;i++) spawnTarget();

function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

function shoot(now){
  if(gun.reloading) return;
  if(now - gun.lastShot < gun.cooldownMs) return;
  if(gun.ammo <= 0){ reload(now); return; }

  gun.lastShot = now;
  gun.ammo--;
  shots++;

  // recoil/spread: increase, then decay in update
  spread = Math.min(spread + 10, 60);

  // hitscan: use crosshair with random spread
  const sx = cross.x + (Math.random()*2-1)*spread;
  const sy = cross.y + (Math.random()*2-1)*spread;

  // check targets
  for(const t of targets){
    if(!t.alive) continue;
    const dx = sx - t.x, dy = sy - t.y;
    if(dx*dx + dy*dy <= t.r*t.r){
      t.alive = false;
      hits++;
      score += Math.round(1000 / t.r);
      setTimeout(() => { // respawn
        const idx = targets.indexOf(t);
        if(idx>=0) targets.splice(idx,1);
        spawnTarget();
      }, 250);
      break;
    }
  }
}

function reload(){
  if(gun.reloading) return;
  gun.reloading = true;
  setTimeout(() => {
    gun.ammo = gun.magSize;
    gun.reloading = false;
  }, gun.reloadMs);
}

function pointerMove(e){
  const rect = c.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (c.width/rect.width);
  const y = (e.clientY - rect.top) * (c.height/rect.height);
  cross.x = clamp(x, 0, c.width);
  cross.y = clamp(y, 0, c.height);
}

c.addEventListener('pointermove', pointerMove);
c.addEventListener('pointerdown', (e) => { pointerMove(e); shoot(performance.now()); });
window.addEventListener('keydown', (e) => {
  if(e.key.toLowerCase() === 'r') reload();
  if(e.key === ' ') shoot(performance.now());
});

function draw(){
  ctx.clearRect(0,0,c.width,c.height);

  // background grid
  ctx.globalAlpha = 0.15;
  ctx.strokeStyle = '#9ca3af';
  for(let y=0;y<c.height;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(c.width,y); ctx.stroke(); }
  ctx.globalAlpha = 1;

  // targets
  for(const t of targets){
    if(!t.alive) continue;
    ctx.beginPath(); ctx.arc(t.x,t.y,t.r,0,Math.PI*2);
    ctx.fillStyle = '#ef4444'; ctx.fill();
    ctx.beginPath(); ctx.arc(t.x,t.y,t.r*0.55,0,Math.PI*2);
    ctx.fillStyle = '#f59e0b'; ctx.fill();
    ctx.beginPath(); ctx.arc(t.x,t.y,t.r*0.22,0,Math.PI*2);
    ctx.fillStyle = '#fde68a'; ctx.fill();
  }

  // crosshair
  ctx.strokeStyle = '#e5e7eb';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(cross.x-14, cross.y); ctx.lineTo(cross.x-4, cross.y);
  ctx.moveTo(cross.x+4, cross.y);  ctx.lineTo(cross.x+14, cross.y);
  ctx.moveTo(cross.x, cross.y-14); ctx.lineTo(cross.x, cross.y-4);
  ctx.moveTo(cross.x, cross.y+4);  ctx.lineTo(cross.x, cross.y+14);
  ctx.stroke();

  // spread circle (shows bloom)
  ctx.globalAlpha = 0.25;
  ctx.beginPath(); ctx.arc(cross.x,cross.y,spread,0,Math.PI*2);
  ctx.strokeStyle = '#93c5fd'; ctx.stroke();
  ctx.globalAlpha = 1;

  // HUD
  const acc = shots ? Math.round((hits/shots)*100) : 0;
  hud.textContent =
    `Score: ${score}\nShots: ${shots}  Hits: ${hits}  Acc: ${acc}%\nAmmo: ${gun.ammo}/${gun.magSize}` +
    (gun.reloading ? ` (reloading...)` : `\n[R] reload, Space/tap to shoot`);
}

let last = performance.now();
function loop(now){
  const dt = now - last; last = now;
  // decay spread
  spread = Math.max(0, spread - dt*0.05);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
